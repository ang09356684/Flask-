# 建立使用者身分驗證

接續大型架構中的基本結構，正式進入網站建構流程

# 相關擴充套件

Flask-Login : 管理已經登入的使用者session

Werkzeug : 密碼雜湊與驗證

itsdnagerous : 以加密的方式保護權證的生成與驗證

Flask-Mail : 傳送身分驗證email

Flask-Bootstrap : HTML 模板

Flask-WTF :  web 表單

# 用Werkzeug 將使用者密碼加密

## werkzeug的security模組提供兩個函式分別用在註冊與驗證

註冊時的hash加密

```python
generate_password_hash(password, method='pbkdf2:sha256', salt_length=8)
```

輸入純文字密碼，會回傳一個hash過的字串 ( salt是隨機加密的元件)，再存在資料庫中

登入時的驗證

```python
check_password_hash(hash, password)
```

將資料庫中的hash過的字串, 和使用者輸入的密碼做比較，若回傳True 表示密碼ˋ正確

flasky/app/models.py

```python
class User(db.Model):
    __tablename__ = 'users'
    id = db.Column(db.Integer, primary_key=True)
    username = db.Column(db.String(64), unique=True, index=True)
    role_id = db.Column(db.Integer, db.ForeignKey('roles.id'))
    password_hash = db.Column(db.String(128))

		@property  # property 是只能讀取的屬性特性
    def password(self): 
        raise AttributeError('password is not a readable attribute')

    @password.setter  # 因為已經用property限定password唯讀, 要另外用setter才能修改
    def password(self, password): # 將輸入的密碼加密
        self.password_hash = generate_password_hash(password)

    def verify_password(self, password): # 驗證輸入的密碼與user model中hash的字串
        return check_password_hash(self.password_hash, password)

    def __repr__(self):
        return '<User %r>' % self.username
```

[@property 裝飾器的說明，務必讀熟](https://www.maxlist.xyz/2019/12/25/python-property/)

使用shell 驗證功能

當輸入完密碼嘗試從model讀取時會跳出警告訊息 

```bash
flask shell
>>> u = User()
>>> u.password = '123abc'
>>> u.password
Traceback (most recent call last):
  File "<console>", line 1, in <module>
  File "D:\flask_learning2\app\models.py", line 24, in password
    raise AttributeError('password is not a readable attribute')
AttributeError: password is not a readable attribute
```

只提供加密後的字串可以查詢

驗證密碼正確與否

```bash
>>> u.password_hash
'pbkdf2:sha256:150000$sOWsVsSo$4ce087f7acb557ea8b1947278e27816c9d5eeca760abb0a7c76ffad1fa83c008'

>>> u.verify_password('123abc')
True
>>> u.verify_password('abc123')
False
```

即便不同使用者的密碼相同

也不會得到相同的加密字串

```bash
>>> u2 = User()
>>> u2.password = '123abc'
>>> u2.password_hash
'pbkdf2:sha256:150000$p01BIofL$79da52b57425ba3ee69d41131a04de6eb0f03e5b3bf45f8cfd0d81baf6d896eb'
>>>
```

## 撰寫單元測試

針對密碼驗證

/tests/test_user_model.py

```python
import unittest
from app import create_app, db
from app.models import User

class UserModelTestCase(unittest.TestCase):
    def setUp(self):
        self.app = create_app('testing')  # 建立測試環境
        self.app_context = self.app.app_context()
        self.app_context.push()
        db.create_all()

    def tearDown(self):
        db.session.remove()
        db.drop_all()
        self.app_context.pop()

    def test_password_setter(self):  # 設定密碼
        u = User(password='abc')
        self.assertTrue(u.password_hash is not None)

    def test_no_password_getter(self):  # 驗證是否觸發@property的唯讀屬性
        u = User(password='abc')
        # assertRaises() 用來驗證是否觸發一個特定的 exception。
        with self.assertRaises(AttributeError):
            u.password

    def test_password_verfication(self):  # 驗證密碼比對
        u = User(password='abc')
        self.assertTrue(u.verify_password('abc'))
        self.assertFalse(u.verify_password('123'))

    def test_password_salts_are_random(self): # 驗證不同使用者hash字串部會相等
        u1 = User(password='abc')
        u2 = User(password='abc')
        self.assertTrue(u1.password_hash != u2.password_hash)
```

結果

```bash
(venv) D:\flask_learning2>flask test
test_app_exists (test_basics.BasicsTestCase) ... ok
test_app_is_testing (test_basics.BasicsTestCase) ... ok
test_no_password_getter (test_user_model.UserModelTestCase) ... ok
test_password_salts_are_random (test_user_model.UserModelTestCase) ... ok
test_password_setter (test_user_model.UserModelTestCase) ... ok
test_password_verfication (test_user_model.UserModelTestCase) ... ok

----------------------------------------------------------------------
Ran 6 tests in 0.593s

OK
```

# 建立身分驗證藍圖 auth

將使用者身分驗證系統的路由加入第二個藍圖 (auth)，讓app的每個子系統都用不同的藍圖維持整齊

## 藍圖建構式

app/auth/__init__.py

```python
from flask import Blueprint

```

## 藍圖路由 views

app/auth/views.py

```python
from flask import render_template
from .import auth

@auth.route('/login')
def login():
    return render_template('auth/login.html')
```

render_template() 的模板路徑是在app/templates裡面，因此只要將模板藍圖放在/templates/auth目錄底下，就不會和先前的藍圖發生命名衝突的風險

## login 模板

目前此模板沒有任何內容 只有瀏覽器上的分頁名稱

app/templates/login.html

```python
{% extends "base.html" %}

{% block title %}Flasky - Login{% endblock %}

{% block page_contend %}
<div class="page-header">
    <h1>Login</h1>
</div>
{% endblock %}
```

## 指派藍圖給create_app()

app/__init__.py

```python
from flask import Flask
from flask_bootstrap import Bootstrap
from flask_mail import Mail
from flask_moment import Moment
from flask_sqlalchemy import SQLAlchemy
from config import config

bootstrap = Bootstrap()
mail = Mail()
moment = Moment()
db = SQLAlchemy()

def create_app(config_name):
    app = Flask(__name__)
    app.config.from_object(config[config_name])
    config[config_name].init_app(app)

    bootstrap.init_app(app)
    mail.init_app(app)
    moment.init_app(app)
    db.init_app(app)

    from .main import main as main_blueprint
    app.register_blueprint(main_blueprint)

		# 新增auth 藍圖
    from .auth import auth as auth_blueprint
    app.register_blueprint(auth_blueprint, url_prefix='/auth')

    return app
```

url_prefix 一旦使用，此藍圖中的路徑就會被加上前置詞 

以login 為例，從 [http://127.0.0.1:5000/login](http://127.0.0.1:5000/auth/login) 變成 [http://127.0.0.1:5000/auth/login](http://127.0.0.1:5000/auth/login)

# 使用Flask-Login 做使用者身分驗證

使用者登入時需要再session中記錄使用者的驗證狀態，以便在瀏覽不同的網頁時寄住身分

flask-login是專門用來管理使用者身分驗證系統的驗證機制

## 安裝

```python
pip install flask-login
```

## 準備使用者Model

flask-login會和user物件緊密相關，flask-login 要求user物件實作一些屬性與方法

Flask-Login有UserMixin類別 實作了許多方法

Flask-Login 需要的項目

```markdown
| 特性/方法        | 說明                                             |
|------------------|--------------------------------------------------|
| is_authenticated | 如果使用者提供有效的登入憑證會是True 否則為False |
| is_active        | 允許使用者登入是True， Flase可用在禁用帳號       |
| is_anonymous     | 一般使用者為False，匿名使用者是True              |
| get_id()         | 必須回傳使用者獨有的辨識碼，編碼成unicode        |
```

修改app/models.py的 User class

將UserMixin 放入User class 繼承項目，新增email欄位

```python
from . import db
from werkzeug.security import generate_password_hash, check_password_hash
from flask_login import UserMixin # 新增import

class Role(db.Model):
    __tablename__ = 'roles'
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(64), unique=True)
    users = db.relationship('User', backref='role', lazy='dynamic')

    def __repr__(self):
        return '<Role %r>' % self.name

class User(UserMixin, db.Model): # 將UserMixin放入 User class
    __tablename__ = 'users'
    id = db.Column(db.Integer, primary_key=True)
    username = db.Column(db.String(64), unique=True, index=True)
    email = db.Column(db.String(64), unique=True, index=True) # 讓使用者可以用email 登入
    role_id = db.Column(db.Integer, db.ForeignKey('roles.id'))
    password_hash = db.Column(db.String(128))

    @property  # property 是只能讀取的屬性特性
    def password(self):
        raise AttributeError('password is not a readable attribute')

    @password.setter  # 因為已經用property限定password唯讀, 要另外用setter才能修改
    def password(self, password):
        self.password_hash = generate_password_hash(password)

    def verify_password(self, password): # 驗證輸入的密碼與user model中hash的字串
        return check_password_hash(self.password_hash, password)

    def __repr__(self):
        return f'<User {self.username}>'
```

## 初始化Flask-Login

要在app工廠函式內初始化

[參考教學文章1](https://hackmd.io/@shaoeChen/ryvr_ly8f?type=view)

[參考教學文章2](https://ithelp.ithome.com.tw/articles/10224408)

app/__init__.py

```python
from flask import Flask
from flask_bootstrap import Bootstrap
from flask_mail import Mail
from flask_moment import Moment
from flask_sqlalchemy import SQLAlchemy
from config import config
from flask_login import LoginManager

bootstrap = Bootstrap()
mail = Mail()
moment = Moment()
db = SQLAlchemy()

# 設定登入端點
login_manager = LoginManager() 
login_manager.login_view = 'auth.login' #當未登入使用者嘗試進入時會轉跳到登入頁面

def create_app(config_name):
    app = Flask(__name__)
    app.config.from_object(config[config_name])
    config[config_name].init_app(app)

    bootstrap.init_app(app)
    mail.init_app(app)
    moment.init_app(app)
    db.init_app(app)
    login_manager.init_app(app)

    from .main import main as main_blueprint
    app.register_blueprint(main_blueprint)

    from .auth import auth as auth_blueprint
    app.register_blueprint(auth_blueprint, url_prefix='/auth')  # 補上url前置路徑

    return app
```

login_manager.login_view = 'auth.login'

login_view 是設定登入網站的端點，因為登入路由在auth藍圖中所以要加上藍圖名稱

當使用者還沒登入，卻請求了一個需要登入權限才能觀看的網頁時，我們就先送使用找到login_view所指定的位置來。以這行程式碼為例，當未登入的使用者請求了一個需要權限的網頁時，就將他送到代表login()的位址去

最後Flask-Login要求app要指定一個當使用者識別碼從資料庫載入使用者時要呼叫的函式

app/models.py

```python
from werkzeug.security import generate_password_hash, check_password_hash
from flask_login import UserMixin
from . import db, login_manager

class Role(db.Model):
    __tablename__ = 'roles'
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(64), unique=True)
    users = db.relationship('User', backref='role', lazy='dynamic')

    def __repr__(self):
        return '<Role %r>' % self.name

class User(UserMixin, db.Model):
    __tablename__ = 'users'
    id = db.Column(db.Integer, primary_key=True)
    username = db.Column(db.String(64), unique=True, index=True)
    email = db.Column(db.String(64), unique=True, index=True) # 讓使用者可以用email 登入
    role_id = db.Column(db.Integer, db.ForeignKey('roles.id'))
    password_hash = db.Column(db.String(128))

    @property  # property 是只能讀取的屬性特性
    def password(self):
        raise AttributeError('password is not a readable attribute')

    @password.setter  # 因為已經用property限定password唯讀, 要另外用setter才能修改
    def password(self, password):
        self.password_hash = generate_password_hash(password)

    def verify_password(self, password): # 驗證輸入的密碼與user model中hash的字串
        return check_password_hash(self.password_hash, password)

    def __repr__(self):
        return f'<User {self.username}>'

@login_manager.user_loader  # 向flask-login 註冊此函式 (注意並不在兩個class內部)
def load_user(user_id): 
    return User.query.get(int(user_id))
```

**login_manager.user_loader** 註冊後，當flask-login 需要取的已登入使用者的資料時就會呼叫此function

使用者id 需要以字串傳入函式會轉換成整數，再交由Flask-SQLAlchemy查詢符合的物件資料，若不存在回傳None

# 保護路由

Flask-Login提供login-required裝飾器，只允許通過驗證的使用者照訪該路由

app/auth/views.py

```python
from flask import render_template
from .import auth
from flask_login import login_required

@auth.route('/login')
def login():
    return render_template('auth/login.html')

# 測試保護路由
@auth.route('/secret') 
@login_required # 未經登入驗證的會被擋掉
def secret():
    return 'Only authenticated users are allowed!'
```

裝飾器可以串接多個，每個裝飾器除了目標function外，只會影響該裝飾器下面的那些裝飾器

login_required 會把沒有經過登入驗證的使用者在嘗試進入 auth/secret 路徑時擋下 

並且將其[導向到app/__init__.py]() 中login_manager.login_view = 'auth.login'  所指定的login頁面

直接輸入[http://127.0.0.1:5000/auth/secret](http://127.0.0.1:5000/auth/secret) 被轉跳到auth/login 的頁面(目前只有title改變) 並跳出提示訊息

![%E5%BB%BA%E7%AB%8B%E4%BD%BF%E7%94%A8%E8%80%85%E8%BA%AB%E5%88%86%E9%A9%97%E8%AD%89%20e91f7360d27548c38b554a26b678c5ba/Untitled.png](User_authentication_img/Untitled.png)

login_required 先將secret保護，避免被未經驗證的使用(與取得轉跳設定)後，才被註冊成路由
所以才能正確轉跳到Login 頁面

但若將兩個裝飾器調換位置 就不會被轉跳到login 頁面

```python
# 測試保護路由
@login_required # 未經登入驗證的會被擋掉
@auth.route('/secret') 
def secret():
    return 'Only authenticated users are allowed!'
```

![%E5%BB%BA%E7%AB%8B%E4%BD%BF%E7%94%A8%E8%80%85%E8%BA%AB%E5%88%86%E9%A9%97%E8%AD%89%20e91f7360d27548c38b554a26b678c5ba/Untitled%201.png](User_authentication_img/Untitled%201.png)

因為原本的secret function 會在被login_required裝飾器接收其他特性之前就被註冊成路由
所以能夠直接進入auth/secret 看到secret回傳的字串

# 登入表單

## 欄位表單部分

email , 密碼, 記住我的確認方塊, 送出按鈕

 app/auth/forms.py

```python
from flask_wtf import FlaskForm
from wtforms import StringField, PasswordField, BooleanField, SubmitField
from wtforms.validators import DataRequired, Length, Email

class LoginForm(FlaskForm):
    email = StringField('Email',validators=[DataRequired(), Length(1, 64), Email()]) # 驗證一定要有資料 長度範圍與 email格式
    password = PasswordField('Passowrd', alidators=[DataRequired()]) #'表示 input type="password"
    remember_me = BooleanField('Keep me logged in')
    submit = SubmitField('Login')
```

email 的驗證會由左到右順序判斷

要做db migrate 加入新的欄位

```bash
flask db migrate -m "add email column"
flask db upgrade
```

## 模板部分

此處只用Flask-Bootstrap的wtf.quick_form()巨集轉譯表單

app/templates/auth/login.html

```python
{% extends "base.html" %}
{% import "bootstrap/wtf.html" as wtf %}

{% block title %}Flasky - Login{% endblock %}

{% block page_content %}
<div class="page-header">
    <h1>Login</h1>
</div>
<div class="col-md-4">
    {{ wtf.quick_form(form) }}
</div>
{% endblock %}
```

修改 app/templates/base.html

在上方nav bar串接Log in 與 Log out連結

```html
{% extends "bootstrap/base.html" %} <!-- 繼承Bootstrap的基礎模版 -->

{% block title %}Flasky{% endblock %}

{% block head %}
{{ super() }}
<link rel="shortcut icon" href="{{ url_for('static', filename='favicon.ico') }}" type="image/x-icon">
<link rel="icon" href="{{ url_for('static', filename='favicon.ico') }}" type="image/x-icon">
{% endblock %}

{% block navbar %}
<div class="navbar navbar-inverse" role="navigation">
    <div class="container">
        <div class="navbar-header">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="{{ url_for('main.index') }}">Flasky</a>
        </div>
        <div class="navbar-collapse collapse">
            <ul class="nav navbar-nav">
                <li><a href="{{ url_for('main.index') }}">Home</a></li>
            </ul> 
            <!--     添加login logout 標籤連結       -->
            <ul class="nav navbar-nav navbar-right"> 
                {% if current_user.is_authenticated %} 
                <li><a href="{{ url_for('auth.logout') }}">Log Out</a></li>
                {% else %}
                <li><a href="{{ url_for('auth.login') }}">Log In</a></li>
                {% endif %}
            </ul>
        </div>
    </div>
</div>
{% endblock %}
```

在if 判斷中的current_user 是Flask-Login所定義的，view函式和template都可以使用

is_authenticated 在沒有登入的情況下(使用匿名代理物件時)會被設為False，用來了解目前使用者是否登入

## 修正Login Logout路由

app/auth/views.py

```python
from flask import render_template, redirect, request, url_for, flash
from .import auth
from flask_login import login_required, login_user, logout_user
from .forms import LoginForm
from ..models import User

@auth.route('/login', methods=['GET', 'POST'])
def login():
    form = LoginForm() # 創建要傳入模板的表單
    if form.validate_on_submit():  # 若表單被送出
        user = User.query.filter_by(email=form.email.data.lower()).first()
        if user is not None and user.verify_password(form.password.data):
            login_user(user, form.remember_me.data)  # 幫使用者session紀錄已登入
            next = request.args.get('next')
            print(request.args)
            print(next)
            if next is None or not next.startswith('/'):
                next = url_for('main.index')
            return redirect(next)
        flash('Invalid email or password') # 錯誤時跳出提示訊息
    return render_template('auth/login.html', form=form)

@auth.route('/logout') # 登出路由
@login_required
def logout():
    logout_user()
    flash('You have been logged out.')
    return redirect(url_for('main.index'))

# 測試保護路由
@auth.route('/secret')
@login_required
def secret():
    return 'Only authenticated users are allowed!'
```

login

當表單被送出的時候，Flask-WTF的validate_on_submit( ) 會驗證表單變數

之後嘗試將使用者登入

login_user( ) 接收要登入的使用者 ( user 物件) 和 remeber me 的布林值，

若remember me 為False ，在瀏覽器關閉時會讓使用者session 過期，下次就需要再登入

True 會在使用者瀏覽器設定長期的cookie，下次Flask-Login就會用此cookie來回復使用者session

在 config 可以修改 REMEMBER_COOKIE_DURATION 改變一年期限的預設值

[request.args.get('next') 相關說明](https://www.huaweicloud.com/articles/b749ce24206e29a4baf5988bfcafd2f3.html)

## 修改login 模板

```bash
{% extends "base.html" %}
{% import "bootstrap/wtf.html" as wtf %}

{% block title %}Flasky - Login{% endblock %}

{% block page_content %}
<div class="page-header">
    <h1>Login</h1>
</div>
<div class="col-md-4">
    {{ wtf.quick_form(form) }}
</div>
{% endblock %}
```

## 測試登入

修改app/templates/index.html

```html
{% extends "base.html" %}
{% import "bootstrap/wtf.html" as wtf %}

{% block title %}Flasky{% endblock %}

{% block page_content %}
<div class="page-header">
    <h1>Hello, {% if current_user.is_authenticated %}
                {{ current_user.username }}
                {% else %}Stranger
                {% endif %}!</h1>
</div>
{% endblock %}
```

從shell 新增使用者

```bash
flask shell
>>> u = User(email='test@gmail.com', username='john', password='cat')
>>> db.session.add(u)
>>> db.session.commit()
>>> exit()
```

[http://127.0.0.1:5000/auth/login](http://127.0.0.1:5000/auth/login)

![%E5%BB%BA%E7%AB%8B%E4%BD%BF%E7%94%A8%E8%80%85%E8%BA%AB%E5%88%86%E9%A9%97%E8%AD%89%20e91f7360d27548c38b554a26b678c5ba/Untitled%202.png](User_authentication_img/Untitled%202.png)

成功登入會轉跳到首頁

[http://127.0.0.1:5000/](http://127.0.0.1:5000/)

![%E5%BB%BA%E7%AB%8B%E4%BD%BF%E7%94%A8%E8%80%85%E8%BA%AB%E5%88%86%E9%A9%97%E8%AD%89%20e91f7360d27548c38b554a26b678c5ba/Untitled%203.png](User_authentication_img/Untitled%203.png)

login() 印的訊息

```python
print(request.args) # ImmutableMultiDict([])
print(next) # None
```

![%E5%BB%BA%E7%AB%8B%E4%BD%BF%E7%94%A8%E8%80%85%E8%BA%AB%E5%88%86%E9%A9%97%E8%AD%89%20e91f7360d27548c38b554a26b678c5ba/Untitled%204.png](User_authentication_img/Untitled%204.png)

## Flask-Login的運作模式說明

1.  使用者按下Login 頁簽連結，到[http://localhost:5000/auth/login](http://localhost:5000/auth/login)  此url 的handler 處理常式 (路由function)會回傳login form 的模板
2. 使用者輸入名稱與密碼後按下submit，會再次呼叫同一個handler，但是改用POST，而不是一開始的GET

    a. handler 會驗證表單送來的憑證，接著呼叫Flask-Login 的 Login_user

    b. login_user() 函示用字串格式將使用者的ID寫進session

3. 瀏覽器收到轉址並請求到首頁

    a. 呼叫首頁的view 函式，view函式觸發主Jinja2模板的轉譯

    b.在轉譯Jiaja2模板期間，首次出現Flask_Login的Current_user的參考

    c.這個reqest的current_user context變數還沒有被賦值，所以他呼叫Flask_Login的內部函式_get_user()來找出這位使用者是誰

    d. _get_user()函式查看使用者session裡面有沒有使用者ID。如沒有，他會回傳Flask-Login的AnonymousUser的實例。如果有ID，他會呼叫app用user_loader裝飾器註冊的函式，以引數傳入ID

    e. app的user_loader函式從資料庫讀出使用者並回傳它。Flask_Login將它指派給目前這個requset的current_user context的變數

    f.模板收到current_user 的新值

在current_user context變數上面建立的login_required裝飾器會讓被裝飾的view函式

在current_user.is_authenticated 是true才能夠執行。在logout_use()函式會直接刪除使用者session的使用者ID

# 註冊新使用者

## 使用者註冊表單

要求輸入email , 名稱, 密碼

app/auth/forms.py

```python
from flask_wtf import FlaskForm
from wtforms import StringField, PasswordField, BooleanField, SubmitField
from wtforms.validators import DataRequired, Length, Email, Regexp, EqualTo
from wtforms import ValidationError
from ..models import User

class LoginForm(FlaskForm):
    email = StringField('Email', validators=[DataRequired(), Length(1, 64), Email()])
    password = PasswordField('Passowrd', validators=[DataRequired()])
    remember_me = BooleanField('Keep me logged in')
    submit = SubmitField('Login')

class RegistrationForm(FlaskForm):
    email = StringField('Email', validators=[DataRequired(), Length(1, 64), Email()])
    username = StringField('Username', validators=[
        DataRequired(), Length(1, 64),
        Regexp('^[A-Za-z][A-Za-z0-9_.]*$', 0,
               'Usernames must have only letters, numbers, dots or underscores')])
    password = PasswordField('Password', validators=[
        DataRequired(), EqualTo('password2', message='Passwords must match.')])
    # EqualTo 驗證兩次輸入的密碼必須相同
    password2 = PasswordField('Confirm password', validators=[DataRequired()])
    submit = SubmitField('Register')

    # 定義額外的驗證方法
    def validate_email(self, field):
        if User.query.filter_by(email=field.data.lower()).first():
            raise ValidationError('Email already registered.') # 拋出錯誤訊息

    def validate_username(self, field):
        if User.query.filter_by(username=field.data).first():
            raise ValidationError('Username already in use.')
```

username 的部分用Regexp驗證函式確定username的開頭是字母，而且只能是字母、數字、_、和句點

[官網validators文件](https://wtforms.readthedocs.io/en/2.3.x/validators/)

*class* `wtforms.validators.**Regexp**`(*regex*, *flags=0*, *message=None*)

Validates the field against a user provided regexp.**Parameters**
• **regex** – The regular expression string to use. Can also be a compiled regular expression pattern.
• **flags** – The regexp flags to use, for example re.IGNORECASE. Ignored if regex is not a string.
• **message** – Error message to raise in case of a validation error.

下方的validate_email 和 validate_username 是另外添加的驗證方法

只要在表單中使用validate_ 加上欄位名稱，除了一般的validators驗證方式之外，也會同時被呼叫

## 註冊模板

app/templates/auth/register.html

```html
{% extends "base.html" %}
{% import "bootstrap/wtf.html" as wtf %}

{% block title %}Flasky - Register{% endblock %}

{% block page_content %}
<div class="page-header">
    <h1>Register</h1>
</div>
<div class="col-md-4">
    {{ wtf.quick_form(form) }}
</div>
{% endblock %}
```

## login 模板

加入註冊連結 與說明字樣

app/templates/auth/login.html

```html
{% extends "base.html" %}
{% import "bootstrap/wtf.html" as wtf %}

{% block title %}Flasky - Login{% endblock %}

{% block page_content %}
<div class="page-header">
    <h1>Login</h1>
</div>
<div class="col-md-4">
    {{ wtf.quick_form(form) }}
    <br>
    <p>New user? <a href="{{ url_for('auth.register') }}">Click here to register</a>.</p>
</div>
{% endblock %}
```

## 註冊使用者路由

app/auth/views.py

```python
from flask import render_template, redirect, request, url_for, flash
from flask_login import login_user, logout_user, login_required
from . import auth
from .. import db
from ..models import User
from .forms import LoginForm, RegistrationForm

@auth.route('/login', methods=['GET', 'POST'])
def login():
    form = LoginForm()
    if form.validate_on_submit():  # 若表單被送出
        user = User.query.filter_by(email=form.email.data.lower()).first()
        if user is not None and user.verify_password(form.password.data):
            login_user(user, form.remember_me.data)  # 幫使用者session紀錄已登入
            next = request.args.get('next')
            if next is None or not next.startswith('/'): # 功用不明
                next = url_for('main.index')
            return redirect(next)
        flash('Invalid email or password')
    return render_template('auth/login.html',form=form)

@auth.route('/logout')  # 登出路由
@login_required
def logout():
    logout_user() # 重置使用者session 移除登入資訊
    flash('You have been logged out.')
    return redirect(url_for('main.index'))

@auth.route('/register', methods=['GET', 'POST'])
def register():
    form = RegistrationForm()
    if form.validate_on_submit():
        user = User(email=form.email.data.lower(),
                    username=form.username.data,
                    password=form.password.data)
        db.session.add(user)
        db.session.commit()
        flash('You can now login.')
        return redirect(url_for('auth.login'))
    return render_template('auth/register.html', form=form)

# 測試保護路由
@auth.route('/secret')
@login_required
def secret():
    return 'Only authenticated users are allowed!'
```

若兩次密碼不同會跳出提示

註冊成功後會跳到登入頁面 並出現設置的flash訊息

![%E5%BB%BA%E7%AB%8B%E4%BD%BF%E7%94%A8%E8%80%85%E8%BA%AB%E5%88%86%E9%A9%97%E8%AD%89%20e91f7360d27548c38b554a26b678c5ba/Untitled%205.png](User_authentication_img/Untitled%205.png)

![%E5%BB%BA%E7%AB%8B%E4%BD%BF%E7%94%A8%E8%80%85%E8%BA%AB%E5%88%86%E9%A9%97%E8%AD%89%20e91f7360d27548c38b554a26b678c5ba/Untitled%206.png](User_authentication_img/Untitled%206.png)

# 用email 確認帳號有效性

為了驗證email地址 app會在使用者註冊後寄送確認信件，並將新帳號標記為未確認，直到使用者按照email的說明進行操作，證明有收到email。通常會讓使用者按下一個URL連結，此連結裡面會有確認用的權杖 ( confirmation token )

通常最簡單的確認連結為 http://[www.example.com/auth/confirm/](http://www.example.com/auth/confirm/)<id> ，路由的view函式接收到使用者id之後再更改確認狀態，但直接輸入id是不安全的

因此將id換成含有同樣資訊的token ，由伺服器產生有效的確認URL

## 用itsdangerous產生確認權杖(Confirmation token)

[Flask使用加密簽署的cookie防止使用者session的內容被竄改](https://www.notion.so/Web-268d26c367b94d889c7b7067de63fce2)，這種使用者session cookie內含一個由itsdangerous套件生成的加密簽章(cryptographic signature) 。如果使用者session內容被串改，內容和簽章的不一致，Flask會丟棄該session再重新啟動新的。相同概念也可以套用在confirmation token上

[itsdangerous 官方文件](https://itsdangerous.palletsprojects.com/en/1.1.x/)

[相關教學](https://hackmd.io/@shaoeChen/ryhSwsOBM?type=view)

### 基本功能說明

由shell 顯示tisdangerous如何產生含有使用者id 的token

```bash
flask shell
>>> from itsdangerous import TimedJSONWebSignatureSerializer as Serializer
>>> s = Serializer(app.config['SECRET_KEY'], expires_in=3600)
>>> token = s.dumps({ 'confirm': 23 })
>>> token
b'eyJhbGciOiJIUzUxMiIsImlhdCI6MTYxOTMzMTIzNiwiZXhwIjoxNjE5MzM0ODM2fQ.eyJjb25maXJtIjoyM30.pb1Q10sBVtG3wdNxjyNhn3Nzshch-c0_QGaIV9ukg_81Mb3X0e1x7PZsvnU-5mj7g74hq_p_OZNYV
PpEsgF2qQ'
>>> data = s.loads(token)
>>> data
{'confirm': 23}
```

tisdangerous 提供多種token 產生器 ，TimedJSONWebSignatureSerializer 類別，可產生含有到期時間的JSON Web Signatures (JWSs)，此類別的建構式會接受一個密鑰，和過期時間 (單位為秒)

dump() 將收到的資料產生加密簽章

load() 接收token 驗證簽章與到期時間，如果兩者都有效就回傳原始資料，若token無效或過期，會發出exception

過期的訊息

```bash
>>> data = s.loads(token)
Traceback (most recent call last):
  File "<console>", line 1, in <module>
  File "d:\flask_learning2\venv\lib\site-packages\itsdangerous\jws.py", line 202, in loads
    raise SignatureExpired(
itsdangerous.exc.SignatureExpired: Signature expired
```

## 在User models加入Token生成與驗證的功能

新增generate_confirmation_token() 與 confirm ( )

app/models.py

```python
from werkzeug.security import generate_password_hash, check_password_hash
from flask_login import UserMixin
from . import db, login_manager
from itsdangerous import TimedJSONWebSignatureSerializer as Serializer
from flask import current_app

class Role(db.Model):
    __tablename__ = 'roles'
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(64), unique=True)
    users = db.relationship('User', backref='role', lazy='dynamic')

    def __repr__(self):
        return '<Role %r>' % self.name

class User(UserMixin, db.Model):
    __tablename__ = 'users'
    id = db.Column(db.Integer, primary_key=True)
    username = db.Column(db.String(64), unique=True, index=True)
    email = db.Column(db.String(64), unique=True, index=True) # 讓使用者可以用email 登入
    role_id = db.Column(db.Integer, db.ForeignKey('roles.id'))
    password_hash = db.Column(db.String(128))
    confirmed = db.Column(db.Boolean, default=False)  # 新增帳號確認狀態

    @property  # property 是只能讀取的屬性特性
    def password(self):
        raise AttributeError('password is not a readable attribute')

    @password.setter  # 因為已經用property限定password唯讀, 要另外用setter才能修改
    def password(self, password):
        self.password_hash = generate_password_hash(password)

    def verify_password(self, password): # 驗證輸入的密碼與user model中hash的字串
        return check_password_hash(self.password_hash, password)

    def generate_confirmation_token(self, expiration=3600):  # 產生一小時期限包含id內容的token
        s = Serializer(current_app.config['SECRET_KEY'], expiration)
        return s.dumps({'confirm': self.id}).decode('utf-8') # 使用utf-8編碼

    def confirm(self, token):
        s = Serializer(current_app.config['SECRET_KEY'])
        try:
            data = s.loads(token.encode('utf-8'))        
        except:
            return False
        
        if data.get('confirm') != self.id:
            return False
        self.confirmed = True
        db.session.add(self)
        return True

    def __repr__(self):
        return f'<User> {self.username}'

@login_manager.user_loader  # 向flask-login 註冊此函式
def load_user(user_id):
    return User.query.get(int(user_id))
```

## 撰寫單元測試

[擴充原本的test_user_model.py]()

tests/test_user_model.py

```python
import time

# 驗證token 相關的測試
    def test_valid_confirmation_token(self):  # 測試自己產生的token 是否能通過驗證
        u = User(password='cat')
        db.session.add(u)
        db.session.commit()
        token = u.generate_confirmation_token()
        self.assertTrue(u.confirm(token))

    def test_invalid_confirmation_token(self):  # 測試別人的token是否在驗證是會報錯
        u1 = User(password='cat')
        u2 = User(password='dog')
        db.session.add(u1)
        db.session.add(u2)
        db.session.commit()
        token = u1.generate_confirmation_token()
        self.assertFalse(u2.confirm(token))

    def test_expired_confirmation_token(self):  # 測試token過期是否會驗證失敗
        u = User(password='cat')
        db.session.add(u)
        db.session.commit()
        token = u.generate_confirmation_token(1)
        time.sleep(2)
        self.assertFalse(u.confirm(token))
```

## 寄送email

### 擴增註冊路由

[修改原本的註冊路由]()，加入token與寄信

app/auth/views.py

```python
from ..email import send_email

# ....

@auth.route('/register', methods=['GET', 'POST'])
def register():  # 註冊路由
    form = RegistrationForm()
    if form.validate_on_submit():
        user = User(email=form.email.data.lower(),
                    username=form.username.data,
                    password=form.password.data)
        db.session.add(user) 
        db.session.commit()
				# 新增部分
        token = user.generate_confirmation_token() # 註冊成功後將user token 放入模板寄信
        send_email(user.email, 'Confirm Your Account',
                   'auth/email/confirm', user=user, token=token)
        flash('A confirmation email has been sent to you by email.')
        return redirect(url_for('auth.login'))  # 轉跳到登入頁面
    return render_template('auth/register.html', form=form)
```

[send_email 函式位置](https://www.notion.so/EMAIL-363df4457c4d4f96b349f80cf19ac101)

### 新增寄信模板

一般使用url_for( )

```python
url_for('auth.confirm', token=token)
```

這樣會拿到相對位置的url，但在網頁中的轉跳是在同一網域下，所以部會有問題

但在給外部使用時一定要用完整路徑

_external=True 的引數，會要求包含協定 http:// 或 https:// ，主機名稱與port的

```python
url_for('auth.confirm', token=token, _external=True)
```

app/templates/auth/email/confirm.txt

```python
Dear {{ user.username }},

Welcome to Flasky!

To confirm your account please click on the following link:

{{ url_for('auth.confirm', token=token, _external=True) }}

Sincerely,

The Flasky Team

Note: replies to this email address are not monitored.
```

app/templates/auth/email/confirm.html

```html
<p>Dear {{ user.username }},</p>
<p>Welcome to <b>Flasky</b>!</p>
<p>To confirm your account please <a href="{{ url_for('auth.confirm', token=token, _external=True) }}">click here</a>.</p>
<p>Alternatively, you can paste the following link in your browser's address bar:</p>
<p>{{ url_for('auth.confirm', token=token, _external=True) }}</p>
<p>Sincerely,</p>
<p>The Flasky Team</p>
<p><small>Note: replies to this email address are not monitored.</small></p>
```

### 確認使用者帳號

新增confirm路由 與重寄確認信

app/auth/views.py

```python
from flask_login import login_user, logout_user, login_required, \
    current_user

@auth.route('/confirm/<token>')
@login_required
def confirm(token):
    if current_user.confirmed:  # 若登入後已經通過驗證 就轉跳到首頁  避免按下很多次確認token而產生沒必要的工作
        return redirect(url_for('main.index'))
    if current_user.confirm(token):  # 若token正確 會由user model的confirm() 更改確認狀態 由此處送出db.session
        db.session.commit()
        flash('You have confirmed your account. Thanks!')
    else:
        flash('The confirmation link is invalid or has expired.')
    return redirect(url_for('main.index'))

@auth.route('/confirm')
@login_required # 使用者需要在登入下才能重新寄送確認信
def resend_confirmation(): 
    token = current_user.generate_confirmation_token()
    send_email(current_user.email, 'Confirm Your Account',
               'auth/email/confirm', user=current_user, token=token)
    flash('A new confirmation email has been sent to you by email.')
    return redirect(url_for('main.index'))
```

### 過濾未確認的帳號

每一個app都能決定未確認的使用者在帳號確認前可以做甚麼事，其中一種選擇是讓未確認的使用者登入，但在他們取得更多權限之前，只顯示一個網頁要求他們確認帳號。

使用Flask 的 before_request hook (勾點) 執行此步驟

request hook 裝飾器

```markdown
| 名稱                 | 說明                                                                        |
|----------------------|-----------------------------------------------------------------------------|
| before_request       | 註冊在每一個request之前執行的程式                                           |
| before_first_request | 註冊只需要在處理第一個request之前執行的函式，適合用來加入伺服器初始化的工作 |
| after_request        | 註冊需要在每一個requset之後執行的函式，但只會在沒有被處理的異常狀況時執行   |
| teardown_request     | 註冊需要在每一個requeset之後執行的函式，即便在有未處裡的異常狀況下          |
```

因為before_request在藍圖中只會套用到屬於該藍圖的request，因此要改用before_app_request讓所有app request裝上此裝飾器

```python
@auth.before_app_request
def before_request():
    if current_user.is_authenticated \
            and not current_user.confirmed \
            and request.endpoint \
            and request.blueprint != 'auth' \
            and request.endpoint != 'static':
        return redirect(url_for('auth.unconfirmed')) # 轉跳到帳號確認的頁面

@auth.route('/unconfirmed')
def unconfirmed():
    if current_user.is_anonymous or current_user.confirmed:
        return redirect(url_for('main.index'))
    return render_template('auth/unconfirmed.html')
```

before_request() 會在下列三個條件都是True的情況下攔截request

1. 使用者已經登入 current_user.is_authenticated = True
2. 使用者的帳號未經確認
3. 被請求的URL在身分驗證藍圖之外，且不是請求靜態檔案。

(使用者必須經過授權才能照訪身分驗證路由，因為是讓使用者確認帳號或執行其他帳號管理功能的路由)

帳號確認模板

app/templates/auth/unconfirmed.html

```python
{% extends "base.html" %}

{% block title %}Flasky - Confirm your account{% endblock %}

{% block page_content %}
<div class="page-header">
    <h1>
        Hello, {{ current_user.username }}!
    </h1>
    <h3>You have not confirmed your account yet.</h3>
    <p>
        Before you can access this site you need to confirm your account.
        Check your inbox, you should have received an email with a confirmation link.
    </p>
    <p>
        Need another confirmation email?
        <a href="{{ url_for('auth.resend_confirmation') }}">Click here</a>
    </p>
</div>
{% endblock %}
```

# 帳號管理

讓使用者可以變更密碼、重設密碼、更改email地址

## 修改User model

app/models.py

```python
def generate_reset_token(self, expiration=3600):
        s = Serializer(current_app.config['SECRET_KEY'], expiration)
        return s.dumps({'reset': self.id}).decode('utf-8')

    @staticmethod
    def reset_password(token, new_password):
        s = Serializer(current_app.config['SECRET_KEY'])
        try:
            data = s.loads(token.encode('utf-8'))
        except:
            return False
        user = User.query.get(data.get('reset'))
        if user is None:
            return False
        user.password = new_password
        db.session.add(user)
        return True

    def generate_email_change_token(self, new_email, expiration=3600):
        s = Serializer(current_app.config['SECRET_KEY'], expiration)
        return s.dumps(
            {'change_email': self.id, 'new_email': new_email}).decode('utf-8')

    def change_email(self, token):
        s = Serializer(current_app.config['SECRET_KEY'])
        try:
            data = s.loads(token.encode('utf-8'))
        except:
            return False
        if data.get('change_email') != self.id:
            return False
        new_email = data.get('new_email')
        if new_email is None:
            return False
        if self.query.filter_by(email=new_email).first() is not None:
            return False
        self.email = new_email
        db.session.add(self)
        return True

    def __repr__(self):
        return '<User %r>' % self.username
```

## 新增表單

在原本的forms 新增四個表單類別

app/auth/forms.py

```python
from .forms import LoginForm, RegistrationForm, ChangePasswordForm,\
    PasswordResetRequestForm, PasswordResetForm, ChangeEmailForm

# .....

class ChangePasswordForm(FlaskForm):  # 輸入新舊密碼 修改表單
    old_password = PasswordField('Old password', validators=[DataRequired()])
    password = PasswordField('New password', validators=[
        DataRequired(), EqualTo('password2', message='Passwords must match.')])
    password2 = PasswordField('Confirm new password',
                              validators=[DataRequired()])
    submit = SubmitField('Update Password')

class PasswordResetRequestForm(FlaskForm):  # 透過email 修改密碼
    email = StringField('Email', validators=[DataRequired(), Length(1, 64),
                                             Email()])
    submit = SubmitField('Reset Password')

class PasswordResetForm(FlaskForm):  # 重設 輸入新密碼表單
    password = PasswordField('New Password', validators=[
        DataRequired(), EqualTo('password2', message='Passwords must match')])
    password2 = PasswordField('Confirm password', validators=[DataRequired()])
    submit = SubmitField('Reset Password')

class ChangeEmailForm(FlaskForm):  # 修改email表單
    email = StringField('New Email', validators=[DataRequired(), Length(1, 64),
                                                 Email()])
    password = PasswordField('Password', validators=[DataRequired()])
    submit = SubmitField('Update Email Address')

    def validate_email(self, field):
        if User.query.filter_by(email=field.data.lower()).first():
            raise ValidationError('Email already registered.')
```

## 新增auth views 帳戶相關路由

app/auth/views.py

```python
from .forms import LoginForm, RegistrationForm, ChangePasswordForm,\
    PasswordResetRequestForm, PasswordResetForm, ChangeEmailForm

# ....

# 修改帳戶資料相關路由
@auth.route('/change-password', methods=['GET', 'POST'])
@login_required
def change_password():
    form = ChangePasswordForm()  # 輸入新舊密碼表單
    if form.validate_on_submit():
        if current_user.verify_password(form.old_password.data):
            current_user.password = form.password.data
            db.session.add(current_user)
            db.session.commit()
            flash('Your password has been updated.')
            return redirect(url_for('main.index'))
        else:
            flash('Invalid password.')
    return render_template("auth/change_password.html", form=form)

@auth.route('/reset', methods=['GET', 'POST'])
def password_reset_request():
    if not current_user.is_anonymous:
        return redirect(url_for('main.index'))
    form = PasswordResetRequestForm()  # 輸入信箱表單 寄送重設密碼
    if form.validate_on_submit():
        user = User.query.filter_by(email=form.email.data.lower()).first()
        if user:
            token = user.generate_reset_token()
            send_email(user.email, 'Reset Your Password',
                       'auth/email/reset_password',
                       user=user, token=token)
        flash('An email with instructions to reset your password has been '
              'sent to you.')
        return redirect(url_for('auth.login'))
    return render_template('auth/reset_password.html', form=form)

@auth.route('/reset/<token>', methods=['GET', 'POST'])
def password_reset(token):
    if not current_user.is_anonymous:
        return redirect(url_for('main.index'))
    form = PasswordResetForm()  # 輸入兩次新密碼表單
    if form.validate_on_submit():
        if User.reset_password(token, form.password.data):
            db.session.commit()
            flash('Your password has been updated.')
            return redirect(url_for('auth.login'))
        else:
            return redirect(url_for('main.index'))
    return render_template('auth/reset_password.html', form=form)

@auth.route('/change_email', methods=['GET', 'POST'])
@login_required
def change_email_request():
    form = ChangeEmailForm()  # 輸入信箱與密碼表單 寄送更新信箱確認信
    if form.validate_on_submit():
        if current_user.verify_password(form.password.data):
            new_email = form.email.data.lower()
            token = current_user.generate_email_change_token(new_email)
            send_email(new_email, 'Confirm your email address',
                       'auth/email/change_email',
                       user=current_user, token=token)
            flash('An email with instructions to confirm your new email '
                  'address has been sent to you.')
            return redirect(url_for('main.index'))
        else:
            flash('Invalid email or password.')
    return render_template("auth/change_email.html", form=form)

@auth.route('/change_email/<token>')
@login_required
def change_email(token):
    if current_user.change_email(token):
        db.session.commit()
        flash('Your email address has been updated.')
    else:
        flash('Invalid request.')
    return redirect(url_for('main.index'))
```

## 修改頁面模板

修改網站上方nav的標籤，新增下拉選單提供帳號管理

app/templates/base.html

```html
{% extends "bootstrap/base.html" %} <!-- 繼承Bootstrap的基礎模版 -->

{% block title %}Flasky{% endblock %}

{% block head %}
{{ super() }}
<link rel="shortcut icon" href="{{ url_for('static', filename='favicon.ico') }}" type="image/x-icon">
<link rel="icon" href="{{ url_for('static', filename='favicon.ico') }}" type="image/x-icon">
{% endblock %}

{% block navbar %}
<div class="navbar navbar-inverse" role="navigation">
    <div class="container">
        <div class="navbar-header">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="{{ url_for('main.index') }}">Flasky</a>
        </div>
        <div class="navbar-collapse collapse">
            <ul class="nav navbar-nav">
                <li><a href="{{ url_for('main.index') }}">Home</a></li>
            </ul>
            <ul class="nav navbar-nav navbar-right">
                {% if current_user.is_authenticated %}
                <!--  登入狀況下提供下拉選單   -->
                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">Account<b class="caret"></b></a>
                    <ul class="dropdown-menu">
                        <li><a href="{{ url_for('auth.change_password') }}">Change Password</a></li>
                        <li><a href="{{ url_for('auth.change_email_request') }}">Change Email</a></li>
                        <li><a href="{{ url_for('auth.logout') }}">Log Out</a></li>
                    </ul>
                </li>
                {% else %}
                <li><a href="{{ url_for('auth.login') }}">Log In</a></li>
                {% endif %}
            </ul>
        </div>
    </div>
</div>
{% endblock %}

{% block content %}
<div class="container">
    {% for message in get_flashed_messages() %}
    <div class="alert alert-warning">
        <button type="button" class="close" data-dismiss="alert">&times;</button>
        {{ message }}
    </div>
    {% endfor %}

    {% block page_content %}{% endblock %}
</div>
{% endblock %}

{% block scripts %}
{{ super() }}
{{ moment.include_moment() }}
{% endblock %}
```

在login頁面 新增忘記密碼重設選項

app/templates/auth/login.html

```html
{% extends "base.html" %}
{% import "bootstrap/wtf.html" as wtf %}

{% block title %}Flasky - Login{% endblock %}

{% block page_content %}
<div class="page-header">
    <h1>Login</h1>
</div>
<div class="col-md-4">
    {{ wtf.quick_form(form) }}
    <br>
    <p>Forgot your password? <a href="{{ url_for('auth.password_reset_request') }}">Click here to reset it</a>.</p>
    <p>New user? <a href="{{ url_for('auth.register') }}">Click here to register</a>.</p>
</div>
{% endblock %}
```

輸入新舊密碼 修改表單 頁面

app/templates/auth/change_password.html

```python
{% extends "base.html" %}
{% import "bootstrap/wtf.html" as wtf %}

{% block title %}Flasky - Change Password{% endblock %}

{% block page_content %}
<div class="page-header">
    <h1>Change Your Password</h1>
</div>
<div class="col-md-4">
    {{ wtf.quick_form(form) }}
</div>
{% endblock %}
```

輸入信箱 傳送重設密碼 信件頁面

使用PasswordResetRequestForm

app/templates/auth/reset_password.html

```python
{% extends "base.html" %}
{% import "bootstrap/wtf.html" as wtf %}

{% block title %}Flasky - Password Reset{% endblock %}

{% block page_content %}
<div class="page-header">
    <h1>Reset Your Password</h1>
</div>
<div class="col-md-4">
    {{ wtf.quick_form(form) }}
</div>
{% endblock %}
```

重設密碼信件內容

app/templates/auth/email/change_password.html

```html
<p>Dear {{ user.username }},</p>
<p>To reset your password <a href="{{ url_for('auth.password_reset', token=token, _external=True) }}">click here</a>.</p>
<p>Alternatively, you can paste the following link in your browser's address bar:</p>
<p>{{ url_for('auth.password_reset', token=token, _external=True) }}</p>
<p>If you have not requested a password reset simply ignore this message.</p>
<p>Sincerely,</p>
<p>The Flasky Team</p>
<p><small>Note: replies to this email address are not monitored.</small></p>
```

app/auth/email/change_password.txt

```html
Dear {{ user.username }},

To confirm your new email address click on the following link:

{{ url_for('auth.change_email', token=token, _external=True) }}

Sincerely,

The Flasky Team

Note: replies to this email address are not monitored.
```

重設信件內容

app/templates/auth/change_email.html

```python
{% extends "base.html" %}
{% import "bootstrap/wtf.html" as wtf %}

{% block title %}Flasky - Change Email Address{% endblock %}

{% block page_content %}
<div class="page-header">
    <h1>Change Your Email Address</h1>
</div>
<div class="col-md-4">
    {{ wtf.quick_form(form) }}
</div>
{% endblock %}
```

寄送信件內容

app/templates/auth/email/change_email.html

```html
<p>Dear {{ user.username }},</p>
<p>To confirm your new email address <a href="{{ url_for('auth.change_email', token=token, _external=True) }}">click here</a>.</p>
<p>Alternatively, you can paste the following link in your browser's address bar:</p>
<p>{{ url_for('auth.change_email', token=token, _external=True) }}</p>
<p>Sincerely,</p>
<p>The Flasky Team</p>
<p><small>Note: replies to this email address are not monitored.</small></p>
```

app/templates/auth/email/change_email.txt

```html
Dear {{ user.username }},

To confirm your new email address click on the following link:

{{ url_for('auth.change_email', token=token, _external=True) }}

Sincerely,

The Flasky Team

Note: replies to this email address are not monitored.
```

## 修改流程

### 更新密碼

auth/change-password 路由的 change_password( ) -> 帶入ChangePasswordForm 到 templates/auth/change_password.html→ 輸入 新舊密碼→送出更新

### 重設密碼

auth/reset 路由的 password_reset_request( ) →帶入 PasswordResetRequestForm 到 templates/auth/reset_password.html
→ 輸入信箱 → 回到auth/reset 路由的 password_reset_request( ) → 寄送重設密碼信件 (使用 templates/auth/email/reset_password.html )

→ 點選信中連結到 auth/reset/<token> 路由的 password_reset() →帶入 PasswordResetForm 到 templates/auth/reset_passwprd.html

→ 輸入兩次新密碼 → 送出後回到auth/reset/<token> 路由的 password_reset() → 更新密碼→ 轉跳登入頁面

### 重設信箱

auth/change-email路由的 change_email_request( ) → 帶入ChangeEmailForm 到 templates/auth/change_email.html → 輸入新的信箱與自己原本的密碼

→ 送出重設信箱確認信 ( 使用templates/auth/email/change)email.html ) → 點選信中連結到auth/change_email/<token> 的change_email( )

→修改使用者信箱→轉跳首頁

# 單元測試

tests/test_user_model.py

```python
def test_valid_reset_token(self):
        u = User(password='cat')
        db.session.add(u)
        db.session.commit()
        token = u.generate_reset_token()
        self.assertTrue(User.reset_password(token, 'dog'))
        self.assertTrue(u.verify_password('dog'))

    def test_invalid_reset_token(self):
        u = User(password='cat')
        db.session.add(u)
        db.session.commit()
        token = u.generate_reset_token()
        self.assertFalse(User.reset_password(token + 'a', 'horse'))
        self.assertTrue(u.verify_password('cat'))

    def test_valid_email_change_token(self):
        u = User(email='john@example.com', password='cat')
        db.session.add(u)
        db.session.commit()
        token = u.generate_email_change_token('susan@example.org')
        self.assertTrue(u.change_email(token))
        self.assertTrue(u.email == 'susan@example.org')

    def test_invalid_email_change_token(self):
        u1 = User(email='john@example.com', password='cat')
        u2 = User(email='susan@example.org', password='dog')
        db.session.add(u1)
        db.session.add(u2)
        db.session.commit()
        token = u1.generate_email_change_token('david@example.net')
        self.assertFalse(u2.change_email(token))
        self.assertTrue(u2.email == 'susan@example.org')

    def test_duplicate_email_change_token(self):
        u1 = User(email='john@example.com', password='cat')
        u2 = User(email='susan@example.org', password='dog')
        db.session.add(u1)
        db.session.add(u2)
        db.session.commit()
        token = u2.generate_email_change_token('john@example.com')
        self.assertFalse(u2.change_email(token))
        self.assertTrue(u2.email == 'susan@example.org')

    def test_user_role(self):
        u = User(email='john@example.com', password='cat')
        self.assertTrue(u.can(Permission.FOLLOW))
        self.assertTrue(u.can(Permission.COMMENT))
        self.assertTrue(u.can(Permission.WRITE))
        self.assertFalse(u.can(Permission.MODERATE))
        self.assertFalse(u.can(Permission.ADMIN))

    def test_moderator_role(self):
        r = Role.query.filter_by(name='Moderator').first()
        u = User(email='john@example.com', password='cat', role=r)
        self.assertTrue(u.can(Permission.FOLLOW))
        self.assertTrue(u.can(Permission.COMMENT))
        self.assertTrue(u.can(Permission.WRITE))
        self.assertTrue(u.can(Permission.MODERATE))
        self.assertFalse(u.can(Permission.ADMIN))
```

# 完成後的網頁流程

註冊 [http://127.0.0.1:5000/auth/register](http://127.0.0.1:5000/auth/register) 後會轉跳到Login頁面



![%E5%BB%BA%E7%AB%8B%E4%BD%BF%E7%94%A8%E8%80%85%E8%BA%AB%E5%88%86%E9%A9%97%E8%AD%89%20e91f7360d27548c38b554a26b678c5ba/Untitled%207.png](User_authentication_img/Untitled%207.png)

收到的確認信

![%E5%BB%BA%E7%AB%8B%E4%BD%BF%E7%94%A8%E8%80%85%E8%BA%AB%E5%88%86%E9%A9%97%E8%AD%89%20e91f7360d27548c38b554a26b678c5ba/Untitled%208.png](User_authentication_img/Untitled%208.png)

在登入下但還未經過email驗證會被轉跳到確認頁面

[http://127.0.0.1:5000/auth/unconfirmed](http://127.0.0.1:5000/auth/unconfirmed)

![%E5%BB%BA%E7%AB%8B%E4%BD%BF%E7%94%A8%E8%80%85%E8%BA%AB%E5%88%86%E9%A9%97%E8%AD%89%20e91f7360d27548c38b554a26b678c5ba/Untitled%209.png](User_authentication_img/Untitled%209.png)

點選確認性後會跳到首頁顯示自己的使用者名稱

![%E5%BB%BA%E7%AB%8B%E4%BD%BF%E7%94%A8%E8%80%85%E8%BA%AB%E5%88%86%E9%A9%97%E8%AD%89%20e91f7360d27548c38b554a26b678c5ba/Untitled%2010.png](User_authentication_img/Untitled%2010.png)

修改帳戶相關設定

登入狀況下

![%E5%BB%BA%E7%AB%8B%E4%BD%BF%E7%94%A8%E8%80%85%E8%BA%AB%E5%88%86%E9%A9%97%E8%AD%89%20e91f7360d27548c38b554a26b678c5ba/Untitled%2011.png](User_authentication_img/Untitled%2011.png)

更改密碼 [http://127.0.0.1:5000/auth/change-password](http://127.0.0.1:5000/auth/change-password)

輸入畫面

更新成功後

![%E5%BB%BA%E7%AB%8B%E4%BD%BF%E7%94%A8%E8%80%85%E8%BA%AB%E5%88%86%E9%A9%97%E8%AD%89%20e91f7360d27548c38b554a26b678c5ba/Untitled%2012.png](User_authentication_img/Untitled%2012.png)

未登入狀況下 到登入頁面 [http://127.0.0.1:5000/auth/login](http://127.0.0.1:5000/auth/login)

![%E5%BB%BA%E7%AB%8B%E4%BD%BF%E7%94%A8%E8%80%85%E8%BA%AB%E5%88%86%E9%A9%97%E8%AD%89%20e91f7360d27548c38b554a26b678c5ba/Untitled%2013.png](User_authentication_img/Untitled%2013.png)

點選忘記密碼重設

![%E5%BB%BA%E7%AB%8B%E4%BD%BF%E7%94%A8%E8%80%85%E8%BA%AB%E5%88%86%E9%A9%97%E8%AD%89%20e91f7360d27548c38b554a26b678c5ba/Untitled%2014.png](User_authentication_img/Untitled%2014.png)

轉跳到[http://127.0.0.1:5000/auth/reset](http://127.0.0.1:5000/auth/reset) 輸入信箱

![%E5%BB%BA%E7%AB%8B%E4%BD%BF%E7%94%A8%E8%80%85%E8%BA%AB%E5%88%86%E9%A9%97%E8%AD%89%20e91f7360d27548c38b554a26b678c5ba/Untitled%2015.png](User_authentication_img/Untitled%2015.png)

重設後會寄送信件

![%E5%BB%BA%E7%AB%8B%E4%BD%BF%E7%94%A8%E8%80%85%E8%BA%AB%E5%88%86%E9%A9%97%E8%AD%89%20e91f7360d27548c38b554a26b678c5ba/Untitled%2016.png](User_authentication_img/Untitled%2016.png)

![%E5%BB%BA%E7%AB%8B%E4%BD%BF%E7%94%A8%E8%80%85%E8%BA%AB%E5%88%86%E9%A9%97%E8%AD%89%20e91f7360d27548c38b554a26b678c5ba/Untitled%2017.png](User_authentication_img/Untitled%2017.png)

點選信件連結後會帶入token轉跳到[http://127.0.0.1:5000/auth/reset/](http://127.0.0.1:5000/auth/reset/)........ 

輸入兩次新密碼



![%E5%BB%BA%E7%AB%8B%E4%BD%BF%E7%94%A8%E8%80%85%E8%BA%AB%E5%88%86%E9%A9%97%E8%AD%89%20e91f7360d27548c38b554a26b678c5ba/Untitled%2018.png](User_authentication_img/Untitled%2018.png)

轉跳到登入頁面 並出現提示訊息

![%E5%BB%BA%E7%AB%8B%E4%BD%BF%E7%94%A8%E8%80%85%E8%BA%AB%E5%88%86%E9%A9%97%E8%AD%89%20e91f7360d27548c38b554a26b678c5ba/Untitled%2019.png](User_authentication_img/Untitled%2019.png)

在登入狀態下

更換信箱 [http://127.0.0.1:5000/auth/change_email](http://127.0.0.1:5000/auth/change_email)



![%E5%BB%BA%E7%AB%8B%E4%BD%BF%E7%94%A8%E8%80%85%E8%BA%AB%E5%88%86%E9%A9%97%E8%AD%89%20e91f7360d27548c38b554a26b678c5ba/Untitled%2020.png](User_authentication_img/Untitled%2020.png)

跳出提示訊息並轉跳到首頁

![%E5%BB%BA%E7%AB%8B%E4%BD%BF%E7%94%A8%E8%80%85%E8%BA%AB%E5%88%86%E9%A9%97%E8%AD%89%20e91f7360d27548c38b554a26b678c5ba/Untitled%2021.png](User_authentication_img/Untitled%2021.png)

寄信到新信箱的內容



![%E5%BB%BA%E7%AB%8B%E4%BD%BF%E7%94%A8%E8%80%85%E8%BA%AB%E5%88%86%E9%A9%97%E8%AD%89%20e91f7360d27548c38b554a26b678c5ba/Untitled%2022.png](User_authentication_img/Untitled%2022.png)

點選連結後

![%E5%BB%BA%E7%AB%8B%E4%BD%BF%E7%94%A8%E8%80%85%E8%BA%AB%E5%88%86%E9%A9%97%E8%AD%89%20e91f7360d27548c38b554a26b678c5ba/Untitled%2023.png](User_authentication_img/Untitled%2023.png)